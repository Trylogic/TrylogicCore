package tl.starling.view{	import flash.display.Stage;	import flash.system.ApplicationDomain;	import flash.utils.getQualifiedClassName;	import mx.core.IMXMLObject;	import mx.core.IStateClient2;	import starling.display.DisplayObject;	import starling.display.Sprite;	import tl.ioc.IoCHelper;	import tl.ioc.mxml.Resolve;	import tl.starling.viewController.StarlingViewController;	import tl.view.Embed;	import tl.view.EventMap;	[Event(name="added", type="starling.events.Event")]	[Event(name="addedToStage", type="starling.events.Event")]	[Event(name="enterFrame", type="starling.events.Event")]	[Event(name="removed", type="starling.events.Event")]	[Event(name="removedFromStage", type="starling.events.Event")]	[Event(name="triggered", type="starling.events.Event")]	[Event(name="flatten", type="starling.events.Event")]	[Event(name="resize", type="starling.events.Event")]	[Event(name="complete", type="starling.events.Event")]	[Event(name="context3DCreate", type="starling.events.Event")]	[Event(name="rootCreated", type="starling.events.Event")]	[Event(name="removeFromJuggler", type="starling.events.Event")]	[DefaultProperty("data")]	/**	 * Basic IView implementation	 *	 * @see IViewController	 *	 */	public class StarlingView extends Sprite implements IMXMLObject	{		public var eventMaps : Vector.<EventMap>;		protected namespace lifecycle = "http://www.trylogic.ru/view/lifecycle";		private var _controllerClass : Class;		private var _data : Array = [];		private var _controller : StarlingViewController;		public function StarlingView()		{		}		public function get controllerClass() : Class		{			return _controllerClass;		}		public function set controllerClass( value : Class ) : void		{			_controllerClass = value;		}		public function get controller() : StarlingViewController		{			if ( _controller == null )			{				initController();			}			return _controller;		}		public function isAddedToStage() : Boolean		{			return stage != null;		}		public function initController() : void		{			if ( _controllerClass == null || !(_controller is _controllerClass) )			{				destroyController();				var eventMap : EventMap;				// TODO: Should we support this logic? Potentialy cause issues with not included ViewController classes				// if(0) is for refactoring support in commented section				if ( 0 )				{					if ( _controllerClass != null )					{						_controller = new _controllerClass();					}					else					{						var potentialViewControllerClassName : String = getQualifiedClassName( this ) + "Controller";						if ( ApplicationDomain.currentDomain.hasDefinition( potentialViewControllerClassName ) )						{							_controller = new (ApplicationDomain.currentDomain.getDefinition( potentialViewControllerClassName ) as Class)();						}						else						{							_controller = new StarlingViewController();						}					}				}				_controller = _controllerClass == null ? (new StarlingViewController()) : (new _controllerClass());				_controller.initWithView( this );				if ( eventMaps )				{					for each( eventMap in eventMaps )					{						eventMap.bind();					}				}			}		}		public function initialized( document : Object, id : String ) : void		{			initController();			lifecycle::init();		}		public function addElement( element : * ) : void		{			if ( _data.indexOf( element ) != -1 )			{				return;			}			if ( element is Resolve )			{				addElement( element.instance );				return;			}			if ( element is StarlingView )			{				StarlingView( element ).controller.addViewToContainer( this );				return;			}			_data.push( element );			var viewElement : DisplayObject;			if ( element is DisplayObject )			{				viewElement = element as DisplayObject;			}			else if ( element is Embed )			{				viewElement = element.instance as DisplayObject;			}			else			{				return;			}			if ( viewElement != null )			{				addChild( viewElement );			}		}		public function addElementAt( element : *, index : int ) : void		{			addElement( element );			setElementIndex( element, index );		}		public function setElementIndex( element : *, index : int ) : void		{			if ( _data.indexOf( element ) == -1 )			{				return;			}			if ( element is Resolve )			{				setElementIndex( element.instance, index );				return;			}			if ( element is StarlingView )			{				StarlingView( element ).controller.setViewIndexInContainer( element, index );				return;			}			var viewElement : DisplayObject;			if ( element is DisplayObject )			{				viewElement = element as DisplayObject;			}			else if ( element is Embed )			{				viewElement = element.instance as DisplayObject;			}			else			{				return;			}			if ( viewElement != null )			{				setChildIndex( viewElement, index < 0 ? (numChildren + index) : index );			}		}		public function removeElement( element : * ) : void		{			if ( _data.indexOf( element ) == -1 )			{				return;			}			if ( element is Resolve )			{				removeElement( element.instance );				return;			}			if ( element is StarlingView )			{				StarlingView( element ).controller.removeViewFromContainer( this );			}			_data.splice( _data.indexOf( element ), 1 );			var viewElement : DisplayObject;			if ( element is DisplayObject )			{				viewElement = element as DisplayObject;			}			else if ( element is Embed && (element.instance is DisplayObject) )			{				viewElement = element.instance as DisplayObject;			}			else			{				return;			}			if ( viewElement != null && viewElement.parent != null )			{				viewElement.parent.removeChild( viewElement );			}		}		/**		 * Inner childs.		 *		 * @param value		 */		public function set data( value : Array ) : void		{			value = [].concat( value );			var element : *;			for each ( element in _data.concat() )			{				if ( value.indexOf( element ) == -1 )				{					removeElement( element );				}			}			for each ( element in value )			{				if ( _data.indexOf( element ) == -1 )				{					addElement( element );				}				else				{					setElementIndex( element, -1 );				}			}			_data = value;		}		public final function get data() : Array		{			return _data.concat();		}		/**		 * Destroy a IView.		 *		 * @see internalDispose		 *		 */		public final function destroy() : void		{			internalDestroy();			lifecycle::destroy();			destroyController();			data = null;		}		internal function internalDestroy() : void		{		}		private function destroyController() : void		{			var eventMap : EventMap;			if ( _controller )			{				if ( eventMaps )				{					for each( eventMap in eventMaps )					{						eventMap.unbind();					}				}				_controller.initWithView( null );			}		}		/**		 * custom init logic here		 *		 */		lifecycle function init() : void		{		}		/**		 * custom dispose logic here		 *		 */		lifecycle function destroy() : void		{		}	}}